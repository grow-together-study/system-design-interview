# 🧾 대규모 시스템 설계 스터디 회고록 – 10장

**일시:** 2025년 7월 16일 (수) 오후 9시 ~ 10시 10분

**참여자:** 박용훈, 전희진, 수빈, 최선강

---

## ✅ 질문 중심 회고 요약

### 🧑‍💻 전희진

**💬 질문 1**

> 왜 중복 전송을 100% 방지하는 것이 불가능한가요?

* **네트워크 불안정성**: 응답이 손실되거나 지연되는 등 네트워크 자체의 한계로 인해 완벽한 중복 방지가 어려움
* **이론적 한계**: 두 장군 문제(Two Generals Problem)라는 분산 시스템의 이론적 한계 존재
    * 불완전한 통신 채널에서는 완벽한 동시 합의가 불가능함을 증명하는 사고 실험
    * 메시지 신뢰성과 분산 트랜잭션 기법을 결합해 충분히 높은 신뢰도만 달성 가능
* 실무에서는 두 장군 문제까지 깊게 묻지는 않을 것으로 예상되며, 네트워크 문제 정도로 이해해도 충분

**💬 질문 2**

> 알림 시스템을 모니터링 할 때 큐에 쌓인 알림의 개수가 몇 개 정도 쌓여야 증설하는 것이 바람직할까요?

* 단순히 **개수만으로 증설을 결정하지 않음**
* 실제 운영에서는 **종합적인 지표**를 고려:
    * 평균 지연 시간
    * 처리 속도
    * 시스템 리소스 사용률 등
* 책에서는 개수만 언급했지만, 실무에서는 다양한 메트릭을 종합적으로 분석하여 증설 결정

---

### 🧑‍💻 박용훈

**💬 질문 1**

> CAP 이론에 따르다면, 알림 시스템은 CAP 중에서 CP를 만족해야 할 것 같습니다. 그렇다면 A는 C에 비해 우선순위가 왜 낮을까요?

* **CAP 이론 복습**: Consistency(일관성), Availability(가용성), Partition tolerance(네트워크 분할 허용성)
* 분산 환경에서는 P(네트워크 분할)는 필수이므로, C 또는 A 중 선택해야 함
* **알림 시스템에서 일관성이 더 중요한 이유**:
    * 알림이 실시간으로 오지 않아도 사용자에게 큰 차질이 없음 (10-20초 지연 허용 가능)
    * 100개 메시지 중 90개만 도착하는 것보다, 늦더라도 모든 메시지가 도착하는 것이 더 중요
    * 대부분의 알림(배송 완료, 결제 확인 등)은 즉시성보다 완전성이 우선
* **알림의 성격에 따라 다를 수 있음**: 긴급 알림의 경우 예외적으로 가용성이 더 중요할 수도 있음

---

### 🧑‍💻 수빈

**💬 질문 1**

> 알림이 제대로 전송되었는지 어떻게 트래킹할 수 있을까요?

* **제3자 서비스 API 활용**: 대부분의 알림 서비스에서 전송 결과 API 제공
    * 단, 보통은 큐에 접수되었다는 응답이며, 실제 수신 여부와는 다를 수 있음
* **웹훅(Webhook) 활용**: 일부 서비스는 실제 수신/열람 여부를 웹훅으로 알려줌
* **이메일 트래킹**: 1x1 픽셀 이미지를 삽입하여 이메일 열람 여부 확인
    * 사용자가 이메일을 열면 해당 이미지 요청이 서버로 전송됨
* **앱 푸시 알림**: 사용자가 푸시를 터치하여 앱을 열면 API 호출로 트래킹 가능
* **서버 로그/DB**: 서버에서 전송 시도에 대한 로그나 상태를 DB에 저장하여 관리

---

### 🧑‍💻 최선강

**💬 질문 1**

> 각 서비스(알림 서버, 메시지 큐)가 다운되었을 때 어떻게 유지할 수 있을까요?

* **기본적인 이중화/다중화** 구성이 우선
* **일관성을 우선하는 접근법** (CAP의 C 우선):
    * 메시지를 **DB에 먼저 저장** 후 큐로 전송
    * 큐가 다운되면 DB에 계속 적재, 큐가 복구되면 배치로 처리
    * 스케줄러/배치를 통해 DB → 큐 → 외부 서비스 순서로 안정적 처리
* **가용성을 우선하는 접근법** (CAP의 A 우선):
    * 큐가 다운되면 **직접 제3자 서비스로 전송**
    * 빠른 처리 가능하지만 대량 데이터 시 손실 위험
* **우선순위별 차등 대응**:
    * 긴급/중요 알림: 큐 다운 시 직접 전송
    * 일반 알림: DB 저장 후 큐 복구 시 배치 처리
* **장애 복구 패턴**:
    * 서킷 브레이커 패턴으로 장애 감지 및 우회 경로 제공
    * 콜백 기반 상태 관리로 실패한 메시지 재전송
    * 재시도 횟수 제한 및 데드레터 큐 활용

---

## 📝 회고 및 개선 제안

* **이론과 실무의 균형**: 두 장군 문제 같은 이론적 배경까지 다루며 깊이 있는 학습이 이루어짐
* **CAP 이론 실적용**: 단순 암기가 아닌 실제 시스템에서 어떤 선택을 해야 하는지 고민해보는 좋은 기회
* **장애 대응 전략**: 단일 장애점 제거부터 우선순위별 차등 대응까지 다양한 관점에서 접근
* **트래킹 방법의 다양성**: 기본적인 API 호출부터 창의적인 픽셀 트래킹까지 실무에서 활용할 수 있는 다양한 방법 학습

---

## 🔍 보완 학습 제안

* **분산 시스템 이론**: 두 장군 문제, 비잔틴 장군 문제 등 분산 시스템의 기본 이론 학습
* **서킷 브레이커 패턴**: 마이크로서비스 아키텍처에서 장애 전파 방지를 위한 패턴 실습
* **메시지 큐 운영**: Redis, RabbitMQ, Kafka 등 실제 메시지 큐 시스템 운영 경험
* **모니터링 지표 설계**: 알림 시스템의 건강성을 측정할 수 있는 구체적인 지표 및 임계값 설정
* **백프레셔(Backpressure) 제어**: 대량 트래픽 상황에서 시스템 안정성 유지 방법
* **알림 개인화 및 최적화**: 사용자별 알림 선호도, 전송 시간 최적화 등 고도화된 알림 시스템 설계