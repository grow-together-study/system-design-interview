# 🧾 대규모 시스템 설계 스터디 회고록 – 12장

**일시:** 2025년 7월 23일 (수) 오후 9시 ~ 9시 30분

**참여자:** 박이현, 최선강, 전희진

---

## ✅ 질문 중심 회고 요약

### 🧑‍💻 박이현

**💬 질문 1**

> 레디스의 특성상 장애 시에 휘발될 데이터에 대한 리스크는 어떻게 극복하는지?

* **레디스의 휘발성 문제**: 메모리 기반이라 속도는 빠르지만 데이터 손실 위험 존재
* **퍼시스턴스(Persistence) 전략** - 디스크 백업을 통한 내구성 확보:

  **1) RDB (Redis Database) - 스냅샷 방식**
  * 메모리의 전체 데이터를 스냅샷 파일로 생성하여 디스크에 주기적으로 저장
  * TTL 설정과 유사하게 시간 기반 또는 변경 건수 기반으로 백업 주기 설정
  * 예: 60초마다 몇 건, 300초마다 몇 건 변경 시 스냅샷 생성

  **2) AOF (Append Only File) - 로그 방식**
  * 모든 쓰기 연산을 디스크의 로그 파일에 순차적으로 기록
  * 실시간성이 높지만 파일 크기가 커질 수 있음

* **하이브리드 접근**: RDB + AOF 동시 사용으로 효율성과 내구성 모두 확보
* **클러스터링**: 마스터-슬레이브 복제를 통한 고가용성 구성
* **백업 주기 딜레마**: 짧은 주기는 부하 증가, 긴 주기는 데이터 손실 위험 - 적절한 균형점 필요

---

### 🧑‍💻 최선강

**💬 질문 1**

> CPU 2G, RAM 4G이고 Spring 기반 웹소켓에서는 어느 정도의 connection 수가 적당할까요?

* **실무 사례 - 카카오 모빌리티**:
  * 모든 사용자 단말기를 웹소켓으로 연결하여 실시간 위치 추적
  * 폴링 방식 대비 사용자 경험 개선을 위해 비용을 감수하고 웹소켓 선택
  * 경쟁사 대비 차별화된 실시간성 제공 (배민 vs 쿠팡이츠 비교)

* **웹소켓 연결당 메모리 사용량**:
  * **Spring 기반**: 연결당 30~60KB 메모리 소모
  * **4GB RAM 기준**: 1GB는 OS/GC/JVM 용도로 예약, 실제 사용 가능한 메모리는 3GB

* **이론적 vs 실제 연결 수**:
  * **이론적 최대**: 3GB ÷ 50KB = 약 6만 개 연결 가능
  * **실제 권장**: **1,000~2,000개 연결**이 안정적
  * **제약 요인**: GC 오버헤드, 외부 리소스 사용, 블로킹 I/O 특성

* **성능 최적화 방향**:
  * **논블로킹 I/O** 사용 시 더 많은 연결 처리 가능
  * Spring MVC의 블로킹 특성이 연결 수 제한의 주요 원인
  * 메모리 사용률은 실제로 2% 수준 (50~100MB)

---

### 🧑‍💻 전희진

**💬 질문 1**

> Keep-Alive 헤더란 무엇인가요?

* **HTTP 연결 최적화 기법**: HTTP 연결 오버헤드를 줄이기 위한 최적화 방법
* **TCP 연결 비용 문제**:
  * TCP는 3-way handshake(연결) + 4-way handshake(해제) 과정에서 지연 발생
  * HTTP의 무상태 특성으로 매 요청마다 연결-해제 반복
  * DB 연결과 마찬가지로 연결 생성이 가장 비용이 큰 작업

* **Keep-Alive 동작 원리**:
  * HTTP 헤더에 Keep-Alive를 설정하면 TCP 연결을 재사용
  * 여러 HTTP 요청/응답을 하나의 TCP 연결로 처리

* **HTTP 버전별 지원**:
  * **HTTP 1.1**: Keep-Alive 헤더를 명시적으로 설정해야 연결 재사용
  * **HTTP 2.0**: 기본적으로 지속 연결 내장
  * **HTTP 3.0**: UDP 기반으로 지속 연결이 기본, Keep-Alive 불필요

* **현재 상황**: 대부분 HTTP 2.0/3.0 사용 (구글, 네이버 등), 하지만 레거시 시스템에서는 여전히 유용

**💬 질문 2**

> SPOF(Single Point Of Failure)란 무엇인가요?

* **단일 장애 지점**: 하나의 구성 요소가 실패할 경우 전체 시스템이 중단되는 지점
* **위험성**: 서버 한 대만 사용하거나 중요한 구성 요소를 이중화하지 않으면 발생
* **해결 방안**: 분산 시스템, 로드 밸런싱, 복제, 백업 시스템 구축을 통한 고가용성 확보
* **시스템 설계의 핵심**: SPOF 제거가 대규모 시스템 설계의 기본 원칙 중 하나

---

## 📝 회고 및 개선 제안

* **실무 경험의 부족**: 대부분의 참가자가 레디스, 웹소켓 등의 실무 경험이 제한적이어서 이론적 접근에 그침
* **강의 콘텐츠 공유**: 패스트캠퍼스의 채팅 시스템 강의가 실제 구현 경험을 제공하는 좋은 리소스로 언급
* **실시간 시스템의 복잡성**: 채팅과 같은 실시간 시스템이 다른 도메인에 비해 OS, 네트워크 지식을 깊이 요구함을 인식
* **기술 스택의 발전**: HTTP 버전별 차이점을 통해 기술의 발전 과정과 레거시 고려사항 학습

---

## 🔍 보완 학습 제안

* **Redis 실습**: RDB/AOF 백업 전략, 마스터-슬레이브 복제, 클러스터 구성 실습
* **웹소켓 성능 튜닝**:
  * Spring WebFlux, Netty 등 논블로킹 I/O 프레임워크 학습
  * 웹소켓 연결 관리, 메모리 최적화 기법
  * 로드 밸런싱 환경에서의 웹소켓 처리 (Sticky Session, Redis Pub/Sub)
* **HTTP 프로토콜 심화**: HTTP/1.1, 2.0, 3.0의 차이점과 성능 특성 비교
* **실시간 시스템 아키텍처**:
  * 메시지 큐 (Kafka, RabbitMQ) 활용한 채팅 시스템 구현
  * 커넥션 서버와 메시지 서버 분리 아키텍처
* **장애 대응 전략**: SPOF 식별 방법, 고가용성 설계 패턴, 장애 복구 시나리오
* **모니터링 및 알림**: 실시간 시스템의 성능 지표 모니터링, 임계치 설정 및 알림 체계