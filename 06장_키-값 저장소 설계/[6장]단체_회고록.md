# 🧾 대규모 시스템 설계 스터디 회고록 – 6장

**일시:** 2025년 7월 2일 (수) 오후 9시 ~ 10시 15분

**참여자:** 박이현, 박용훈, 전희진

---

## ✅ 질문 중심 회고 요약

### 🧑‍💻 박이현

**💬 질문 1**

> 데이터 다중화에서 가상 노드를 사용한다면 위와 같이 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다는데, 이게 무슨 의미인가요?

* 해시링 상에서 N개의 연속된 가상 노드에 데이터를 저장하는 경우,
  이 노드들이 동일한 물리 서버에 매핑될 수 있음
* 이 경우 복제된 의미가 사라짐 (한 물리 서버에만 저장되므로 장애에 취약)
* 해결책: **물리 서버 중복 선택 방지** 로직을 추가해, 물리적으로 서로 다른 서버에 분산 저장되도록 보장해야 함

---

### 🧑‍💻 박용훈

**💬 질문 1**

> 비일관성 해소 기법에서 버저닝과 벡터 시계에 대해 설명해주실 수 있나요?

* 버저닝: 하나의 키에 대해 여러 값을 버전 번호로 관리 (충돌 감지 및 선택 가능)
* 벡터 시계: 각 노드마다 (노드ID → 버전번호) 형태의 맵으로 인과관계 추적
* 두 업데이트 간 충돌 여부를 정밀하게 판단 가능
* 실무에서는 **충돌 해결 정책과 함께 사용** (최신값 우선, 수동 병합 등)

**💬 질문 2**

> Redis 외의 키-값 저장소 기술들은 어떤 상황에서 사용되나요?

* Redis는 단일 노드 성능 위주의 인메모리 캐시
* 분산 저장/수평 확장이 필요한 경우 Cassandra, DynamoDB, LevelDB 등 사용
* 예:

  * Zookeeper: Kafka 브로커 간 설정 공유
  * Cassandra: 이벤트 로그, 메신저 메시지 기록 등 높은 쓰기 처리량 요구 시

---

### 🧑‍💻 전희진

**💬 질문 1**

> 블룸 필터를 사용하는 경우, 메모리 캐시에 데이터는 언제 등록되나요?

* 이미지 설명엔 생략되었지만, 실제 구현에서는 **디스크에서 데이터를 조회한 이후 등록됨**
* 읽기 요청 → 디스크에서 가져옴 → 응답과 동시에 캐시에 등록
* 캐시 등록 시점은 시스템에 따라 다르지만, 일반적으로 **데이터 응답 직후 등록**

**💬 질문 2**

> 일시적 장애 후 복구된 노드에 데이터를 인계할 때, 해당 노드는 읽기/쓰기를 중지하나요?

* 대부분의 시스템은 완전한 중단 없이 **힌트 전파(Hinted Handoff)** 방식 사용
* 장애 당시 기록을 다른 노드가 임시로 보관하고, 복구 시 다시 전달함
* 복구 중에도 새로운 요청은 계속 처리되므로 **복구 동기화와 클라이언트 요청은 병행 가능**
* 충돌 가능성은 벡터 시계 등으로 탐지하여 병합 처리

---

## 📝 회고 및 개선 제안

* 키-값 저장소는 개념만 익히면 단순해 보이지만, 실제 시스템에서는 **일관성 보장, 장애 복구, 확장성** 등 고려 요소가 많음
* Redis 중심 인식에서 벗어나 **Cassandra, Dynamo 계열 등 분산 저장소의 쓰임새를 체계적으로 정리**할 필요 있음
* 각자 질문이 깊이 있었지만, 일부 개념(예: 벡터 시계, 블룸 필터)는 **사전 그림 기반 설명 준비 시** 이해도 향상 효과가 클 것
* 안정 해시나 키 샤딩 전략처럼 **다른 장과 개념 연계**하며 학습하면 효과적

---

## 🔍 보완 학습 제안

* 가상 노드 + 해시링 구조: 동일 물리 서버 중복 방지 로직 포함하여 설계 실습
* 벡터 시계 구조: 충돌 감지 예제와 함께 시뮬레이션 구현
* Redis vs Cassandra 비교: 일관성 모델, 쓰기 처리 방식, 장애 복구 방식
* 블룸 필터 기반 캐시 설계 흐름 복습 및 TTL 갱신 전략 학습
* Dynamo 스타일 아키텍처(Cassandra, ScyllaDB 등)의 일관성 유지 방식 사례 분석